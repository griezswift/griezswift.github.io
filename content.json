{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"八股","date":"2024-06-05T15:09:20.920Z","updated":"2024-05-08T19:00:14.370Z","comments":true,"path":"2024/06/05/八股/","link":"","permalink":"http://example.com/2024/06/05/%E5%85%AB%E8%82%A1/","excerpt":"","text":"STL 容器： set：键值要求唯一，自动排序，红黑树实现 multiset：键值可重复，自动排序，红黑树实现 unorderd_set：不排序，哈希表实现 map（key : value）：键值对唯一，按规则插入，红黑树实现，节点是键值对 multimap（key : value）：键值对可重复，按规则插入，红黑树实现，节点是键值对 unorderd_set：不排序，哈希表实现 stack,queue：deque实现，是双端队列 priority_queue：vector，堆实现 list：双向链表实现 hash_table：数组+链表实现，线程安全，因为加锁了，效率低，concurrenthash_map做了优化 hash_map：无自动排序，hash_map实现 JAVA集合 ArrayList：Object[] 数组。详细可以查看： Vector：Object[] 数组。 LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素。 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树) PriorityQueue: Object[] 数组来实现小顶堆。 DelayQueue:PriorityQueue。 ArrayDeque: 可扩容动态双向数组 实现自定义排序需要重写compareto方法 hashset如果检查重复：先比较hashcode,,如果相同使用string equal函数对比 JAVA JRE &#x3D; JVM + 已编译文件、库。是java运行时的环境，包含了编译好的java文件集合和java基础类库library JDK &#x3D; JRE + java开发工具，如javac、jdb调试器等 JVM JAVA虚拟机 接口和抽象类的区别 接口定义的是实现类需要必须实现的方法和行为，只能声明方法，不能在方法体中编写具体代码，默认都是抽象方法 抽象类中定义的是继承类中有相同特征的方法和行为 ，可以声明抽象方法和普通方法，方法中可以编写具体的方法体代码，但是接口的方法中不可以编写方法体代码 反射 应用场景：动态代理、注解（运行期通过反射处理注解的解析） 通过反射可以获取任意一个类的所有属性和方法，然后可以调用他们 java获取类对象四种方法： 通过class.forname()传入类全路径 通过对象实例instance.getClass()获取 通过类加载器xxxClassLoader.loadClass()传入类路径获取 序列化和反序列化 目的是持久化java对象，即是实例化后的类class 序列化：数据结构和对象转化成二进制字节流 反序列化：二进制字节流转换程数据结构或者对象 应用场景：网络传输、存储到文件、数据库和redis、内存 不想序列化的变量可以用rtransient修饰，该关键字不能修饰类和方法 static变量不属于任何对象所以不会被序列化 Kryo序列化协议专门针对java，性能非常好，因为具有变长存储特性和字节码生成机制 JDK自带的序列化不支持跨语言调用、存在安全问题（可以恶意构造输入） IO流 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？字符流由jvm将字节转换得到，比较耗时。如果不知道编码类型用字节流会出现乱码问题 设计模式 装饰器模式，通过组合替代继承扩展原始类的功能 适配器模式，用于接口不兼容的类的协调工作。InputStreamReader 和 OutputStreamWriter 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁，通过流解码器和流编码对字节进行解码和对字符编码 工厂模式， 观察者模式，观察者设计模式使订阅者能够从提供程序注册并接收通知。 它适用于需要基于推送的通知的方案。 此模式定义提供程序（亦称为“使用者”或“可观察对象”），以及零个、一个或多个观察者。 观察者注册提供程序，并且每当预定义的条件、事件或状态发生更改时，该提供程序会通过调用委托来自动通知所有观察者。简单说就是定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。NIO文件目录监听使用了这种方案 JVM内存区域 运行时数据区：堆（线程共享）+ 线程地址空间（线程私有）+本地内存 （线程共享）堆存放字符串常量池 （线程私有）线程地址空间包括虚拟机栈、程序计数器PC、本地方法区 （线程共享）本地内存跟运行时数据区分离，里面有元空间存放字符串常量池 垃圾回收 死亡对象判断方法 引用计数法 可达性分析法 如何判断废弃常量？比如：没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量 如何判断一个无用的类？ 所有实例已经回收 加载该类的类加载器已经被回收 类对象没有在其他地方被引用，无法通过反射获取该类的方法 垃圾收集有哪些算法？标记清除算法、复制算法、标记整理算法、分代收集算法 垃圾收集器有哪些？ Serial 串行收集器：新生代采用标记-复制算法，老年代采用标记-整理算法 ParNew 收集器（串行收集器的多线程版本）****新生代采用标记-复制算法，老年代采用标记-整理算法 **Parallel Scavenge **平行收集器是使用标记-复制算法的多线程收集器 JDK1.8的默认收集器 数据库 ACID: 原子性 一致性 隔离性 持久性 事务隔离级别 读取未提交：允许读取未提交的数据变更，可能会脏读 幻读 不可重复读 读取已提交：允许读取已经提交的数据变更，可能会幻读 不可重复读 可重复读：对同一字段多次读数据一致，除非事务自己更改数据，可能会幻读 串行化：所有事务顺序执行，无任何风险 脏读：事务a修改了数据，修改之后事务b读取了这个数据，读取之后事务a回滚了。 不可重复读：mysql默认级别。事务a多次读同一个数据，在此期间事务b修改了数据，导致事务a多次读取的数据不一致,侧重update和delete 幻读：幻读并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：事务a select 某记录是否存在，结果为不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。侧重于insert 脏写：事务a修改数据为a,事务b修改数据为b，事务a回滚，b的数据没有了 慢sql优化 不使用子查询、分组统计禁止不必要排序、 尽量不超过3个表的join，不使用 select * 避免索引失效（避免全表扫描） 不在where后子句字段加函数运算 不进行字段类型转换 搜索只能右模糊 避免对字段进行null 值判断 不在where子句使用动态参数传入 三大日志 错误日志、查询日志、慢查询日志、事物日志等 三大指：归档日志 重做（事务）日志 回滚日志 redo log 重做日志（属于物理日志）：mysql挂了或宕机，重启时引擎会使用重做日志恢复数据，体现崩溃恢复能力 在某个数据页上做了什么修改记录到redo log 缓存中，然后刷盘到redo log 文件中 每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成 binlog 归档日志（属于逻辑日志）：记录所有涉及更新数据的逻辑操作，并且是顺序写，体现数据备份、主从功能、集群同步数据、保证数据一致性 记录的内容是sql语句原文 同步的时候执行记录的语句原文，像日期这种实时性数据需要在语句中具体指定，否则会导致同步的数据不一致。 写入时机：事务执行时日志先写的binlog 缓存，事务提交时把缓存写入到binlog 文件。 undo log 回滚日志：所有事务进行的修改都会先记录到回滚日志中，然后再执行操作。如果执行过程中遇到异常的话，直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。 MVCC 多版本并发控制 通过READ VIEW、回滚日志、隐藏字段实现 隐藏字段： DB_TRX_ID（6字节）记录最后一次插入或更新该行的id DB_ROLL_PTR（7字节）回滚指针，指向这行的回滚日志 DB_ROW_ID（6字节）在一定条件下用于生成聚簇索引的id READ VIEW： 主要是保存了大于等于、小于该事务id的事务id集合、其他未提交的活跃事务列表 目的是用来做事务可见性判断、保存了当前对本事务不可见的其他活跃事务 回滚日志 redo log 事务回滚时候用于数据恢复 mvcc中可以通过 redo log 读取之前的版本数据实现非锁定读 在读取已提交的隔离级别时，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读 在可重复读隔离级别下只在事务开始后 第一次select 数据前生成一个Read View MVCC + Next-key-Lock 防止幻读 操作系统进程线程 进程：计算机中运行的程序实例，是计算机分配资源的单位 线程：多个线程可以在同一个进程中运行，是CPU独立调度和分派的最小单位 区别：一个进程中可以有多个线程，多个线程共享进程的堆栈地址空间和方法区，每个线程会有自己的PC和虚拟机栈、本地方法栈。进程切换开销大，线程切换开销低 多线程好处：减少上下文切换开销、多线程并发编程是高并发系统基础 线程间同步方法：互斥锁 读写锁 信号量 屏障 事件 进程间通信方法：管道 消息队列 信号量 共享内存 socket ​ 计算机网络 HTTP1.0 ： 短链接，存在带宽浪费，明文传输 HTTP1.1：长连接，支持断电续传，加入大量状态响应码，允许一个ip地址托管多个域名、明文传输，连接复用，但是只能按顺序返回请求，会出现队头阻塞。 HTTP2.0：运行在SSL&#x2F;TLS上的HTTP协议,多路复用（同一连接上可以同时传输多个请求和响应，可以避免队头阻塞）、头部压缩、加密传输 URI 统一资源标识符：唯一标识一个资源 URL 统一资源定位符，是路径 GET 获取和查询资源、请求具有幂等性，可以进行缓存加快访问速度 POST 修改和创建资源，请求一般放在body中，另外比GET安全一点 linux命令 cat vim vi 查看 创建 编辑文件 chmod 修改文件权限 reboot 重启系统 cd ls mv 切换目录 查看当前目录 移动目录 df 查看磁盘使用情况 mkdir rmdir 创建文件目录 删除目录 rm -rf 删除任何文件 wget yum install 下载 kill 杀掉进程 tar 解压 git命令 git commit 提交 git clone 克隆到本地 git push 推 git pull 拉取 git rm 删除 git branch 分支 git add 增加内容 docker命令Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等） 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间 docker version 查看版本 docker images 查看所有镜像 docker container ls 查看所有容器 docker ps 查看正在运行的容器 docker search … 搜索相关镜像 docker pull … 拉取镜像 docker stop 停止容器 docker rmi 删除镜像 Springbootspringboot启动流程和自动配置原理@SpringbootApplication包含三个关键注解 ​ @springbootConfiguration:表示启动类是一个自动配置类 ​ @CompontScan:扫描启动类所在包外的组件到容器中 ​ @EnableConfigutarion：启动类所在包下的所有组件全部加载到ioc容器中， 启动流程 加载启动类，也就是@SpringbootApplication标注的类，然后自动配置相应的bean 加载配置文件，从application.yaml配置文件中加载 创建spring容器，使用springbootApplication类创建容器，springapplication类提供了管理bean的方法，如果是springboot web项目会创建一个内置的web服务器 自动加载配置，springboot通过@EnableAutoConfiguration注解完成配置，根据starter依赖中的configuration自动装配相应的bean 运行springboot应用程序，如果是web项目就会启动内置web服务器 springboot依赖注入bean是指被IOC容器管理的对象，对对象声明为bean意味着愿意把对象实例创建给IOC容器进行管理，以下这些注解用于声明bean @bean 对方法生命注解，自定义性更强，第三方库注入用这个 @component 通用注解，对所有组件都适用一般对对象进行注解 @service 对服务层注解 @controller对控制层进行注解 @repository对持久层（dao层）进行注解 @autowired根据属性、类型进行匹配去注入bean @resource根据名称进行匹配去注入bean 如果一个接口有多个实现类，bytype会失效，推荐用byname进行注入，@autowired可以通过@qualifier来显式指定类名称，@resource可以通过name属性来指定 bean的生命周期 通过反射创建bean实例， bean属性赋值填充，用构造函数或包装函数注入依赖和值 bean初始化， 销毁bean，先记录销毁的方法，然后真正需要销毁bean或者容器的时候，调用这些方法去释放bean spring事务失效的情况 数据库引擎不支持事务 添加事务的类没有被IOC容器管理 注解作用的方法不是public 设置了错误的传播特性，注解的rollback属性、propagation属性设置错误 在本方法中继续调用了本方法 解决方法：自己调用自己、自己注入自己 通过AOP代理调用 使用@async注解异步执行，避免在当前线程执行引发出现事务失效 异常被捕获后没有被抛出，事务是通过识别运行时异常进行回滚的 自定义了回滚异常 一般使用REQUIRED、NESTED 、REQUIRED_NEW进行事务传播行为的定义 循环依赖 两个或者多个bean之间相互依赖，导致无法正确创建 如何发现循环依赖 调试工具检测栈和变量信息，观察是否有多个bean对象互相等待初始化的情况 用专门的循环依赖检测工具（ASM JAVASSIST）来检测 添加日志记录，跟踪Bean的创建和注入过程。如果发现日志中存在循环依赖的线索，例如多个Bean相互依赖导致的创建顺序循环 如何解决 两者都使用构造器注入时spring不支持循环依赖，通过参数传递依赖项的方式解决，因为可以保证依赖项在实例化bean的时候已经准备好 两者都使用setter注入时spring支持循环依赖 使用属性自动注入时spring支持循环依赖 使用@lazy注解，让spring在需要的时候延迟加载bean 使用中介者、观察者模式来降低依赖关系 spring三级缓存：内存、本地、网络 通过spring三级缓存解决，是三个map集合，第三层是单例对象工厂缓存（存放对象工厂，用于表示已经存在这个对象），第二层是提前曝光的单例对象缓存（只完成了实例化），第一层是单例对象缓存（实例化、赋值、初始化都完成的） 实例化A的时候把A对象工厂放入三级缓存，表示实例化了，虽然不完整，但是提前暴露 A注入属性时候需要依赖B,然后实例化B B注入属性时候需要依赖A，然后从一级到三级缓存找A,在三级缓存找到后把a放入二级缓存，同时删除三级缓存中的a，此时b实例化、赋值、初始化完成，放到一级缓存 接着a属性赋值，从一级缓存获得b，a对象创建完成，删除二级缓存中的a,把a放入一级缓存。此时两者都完成了实例化、属性赋值和初始化。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-11-18T06:14:12.702Z","updated":"2022-09-14T05:24:44.822Z","comments":true,"path":"2022/11/18/hello-world/","link":"","permalink":"http://example.com/2022/11/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"显示器参数","slug":"显示器","date":"2022-10-31T13:32:54.000Z","updated":"2022-11-09T14:53:44.833Z","comments":true,"path":"2022/10/31/显示器/","link":"","permalink":"http://example.com/2022/10/31/%E6%98%BE%E7%A4%BA%E5%99%A8/","excerpt":"","text":"主要的选择有三种：IPS面板、TN面板、VA面板。对面板不熟悉的朋友可能会纳闷这些面板有什么区别呢？ 注释：⭐越多代表性能越强； 图表中针对各种面板进行了评价，下面对各种面板的特性进行了说明； TN面板：TN面板的色彩表现差，优点是灰阶响应速度很快，可以轻松做到1-5ms，也是很多职业游戏玩家的。但是个人玩家不推荐，致命原因就是因为TN面板的可视角度小，使用时角度偏了可能就看不到了。另外色彩变现一般，色彩画面苍白，用起来不是很爽； VA&#x2F;HVA面板：VA面板一般是曲面屏上拥的比较多，VA面板的可视角度大、黑白对比度高，色彩还原较为精确，但是响应时间慢，面板的均匀性一般，不太适合用于设计或者修图，看电影还不错，HVA是快速VA技术（华星光电），尽力弥补响应时间慢的缺点； IPS面板：IPS面板色彩还原性很好 ，响应速度较快，但是有漏光(但是不影响日常使用，只有在暗光条件，纯黑背景下会较为明显)，可视角度广，面板的色准也更好，也适用于各种场景：游戏(高刷、4A)、办公、设计、修图都可以用上，是很好的一个选择； 显示器品牌 一线（知名度、售后） 戴尔 、华硕、 飞利浦（冠捷）、 三星、 LG、明基（主护眼） 新兴：HKC、联想、冠捷AOC 创维、优派、KTC、泰坦军团（联合创新同公司）、海信、小米（联合创新代工）、华为、方正 二三线或DIY品牌：SANC、易美逊（AOC旗下）、梅捷、科睿 面板品牌 京东方4K N50&gt;N40&gt;N30&gt;N21&gt;N20 友达6.6 8.2是比较早的Fast IPS的面板，6.8和8.0是较新的Fast IPS面板，出现在1000-2000的高刷电竞屏，友达7.0是定位高端的Fast IPS面板 4K面板：友达6.0&gt;2.0 群创K7E &gt; K7B Q7E \\显示器的响应时间一般指**灰阶响应时间(GTG)*，这里用一款2K 144Hz显示器来说，他的响应时间1&#x2F;1441000≈6.94ms，如果显示器面板的GTG时间高于了6.94ms，显示器画面容易出现拖影； 现在有不少的显示器都标榜1ms，他们这个是开启MPRT等技术的时候得到的数据，并且开启之后会加速眼疲劳，不建议开启这个模式来换取高响应，最好去了解这个面板原始的响应时间(有部分显示器能查到，有部分无法查到)； 主流的IPS面板的灰阶响应时间大概在5ms左右现在有Nano IPS和Fast IPS两种基于IPS的新技术； Nano IPS ：是LG开发的面板，色彩表现更好，WLED背光模组，吸收大量的光波来提升显示光输出的纯度和色彩的精度，能够增强色域空间最高可达到98%P3； Fast IPS 快速液晶：是友达光电通过降低液晶层的厚度、加强电压（OD）的方式来达到更快响应速度。宣传1ms GTG，实际上能达到3-5ms GTG（具体看厂商调校） 背光1.背光模组 液晶电视能够发光依靠发光源，而背光的工作就是负责发光。 在背光中有许多的LED灯珠（可以理解成家里电灯里的LED灯珠）然后加上多层光学膜和一块液晶屏幕进行组装，最终就变成了液晶电视。 LED这类背光源是依靠外部光源进行发光的，一般我们称为“被动背光”。WLED是目前中端日常使用产品的主流背光方式。目前液晶电视、被成为新一代技术的Mini LED电视都是采用这种背光方式来发光。 Mini LED背光是把Mini LED作为LCD面板的背光源，通过在背光模组设置大量Mini LED芯片，实现超高对比度、超高亮度、超高色域的画质表现。说通俗点，就是原先的几个大LED背光，换成成千上万个Mini LED发光芯片，所以采用Mini LED背光的电视，亮度和对比度都更优秀。iPad高端型号便是使用Mini LED屏幕 原厂背光模组一般比显示器厂商自组的背光模组好 另外一种则是主动发光，通过屏幕自己来发光。现在高端电视中的OLED和以前的等离子电视都是主动式发光。 2.背光方式被动式背光方式，主要有两种方式：一种是侧入式背光，另一种则是直下式背光。 侧入式背光是把背光源分布在电视机的侧面，优点是可以削减电视机的厚度，缺点是控光方面不够均匀，容易出现漏光现象。 另外侧入式背光在工艺上需要将整体封装屏幕，所以成本上也是高于直下式背光。 左边为侧入式背光 右边为直下式背光 直下式背光则是在液晶背板中均匀地分布着上千个LED灯珠，这样可以让背光可以均匀地分布在屏幕上。 优点是亮度均匀，控光更好，不容易出现漏光现象，并且还能对背光板进行分区，让屏幕每个区域可以独立控制亮度。但缺点是机身的厚度无法做薄。 3.背光分区背光分区是将背光分割成多个区域，进行独立控制。目前直下式背光的优点是将背光区域分割区域面积更小，区域越多，控光的效果也更好。 这种控制方式好处是可以更加精准地控制画面的明暗。 因为需要控制明暗和开关，比如在黑色夜空的场景下，这个时候，就需要关闭没有画面的部分背光，这样背景和画面之间形成一种对比反差，从而让画面更加有层次感。如果没有分区控光，背光会让画面泛白，出现类似漏光的效果。画面有很脏的感觉 色域 主要指显示器的呈色范围（照片也有）。覆盖全区域是人眼可见光谱，当然有的人可能对于红色和绿色分不清（色盲），跟音乐领域的听力一样，专业人士对于色彩的分辨率也高于常人。因为用途不同也分成了许多不同标准。 sRGB：由微软和惠普起草，WINDOWS操作系统和软件常用 100%和99% NTSC：电子电视屏幕色彩标准，覆盖100%sRGB约等72%NTSC Adobe RGB：覆盖sRGB+CMYK色彩空间，主要是作图设计标准 95%以上 DCI-P3：于数字影院的比较新的色彩标准，以人类视觉体验为主 95%以上 Adobe RGB&gt;DCI-P3&gt;sRGB 色深 一般VA面板最高只能到达8bit，而IPS面板可以到达10bit，而有一些显示器厂商，提供了更大的模拟芯片，比如14BIT混色精度，提高色彩准确度，有更好色彩过渡。大部分的显示器1670万色基本可以良好过度，IPS有10.7色深。 注意：大部分10.7亿色显示器不是原生10bit，是8bit通过FRC图像抖动技术通过PWM（脉冲宽度调制）控制像素抖动。可以让8bit接近10bit效果但是并不能做到完全一样，在最终的观感上可能会有小噪点； 色准 为什么实际颜色和显示器差别很大? 广告和服装设计师最关心的色准问题，会极大的影响最终交付客户的色彩呈现。图像设计用途（各种影视处理工作站——动画，影楼等），对于屏幕的真实色彩展示有很高的要求，同时也要求更大的工作区，可以有效提供工作效率。 Delta E表示色彩的准确度，数值越小，色彩越准确，为满足专业摄影师\\图像工作者的严苛要求，一般要求显示器Delta E≤2（平均值），如果Delta E过大，颜色会失真，需要专业校色。显示器不是越浓艳越好，要看跟真实的区别 Delta&lt;3正常，Delta&lt;1优秀。 对比度对比度代表显示器最亮和最暗时刻的亮度比值，相对来说对比度越高越好，因为在画面从最暗变化到最亮的时候，画面的层次感更好； 常见的三种面板： IPS和TN面板的静态对比度为1000：1 VA面板的静态对比度为3000：1 另外在选购显示器的时候还会看对比度为800W：1(甚至更高的数值)，这个是动态对比度，1000W:1以上也是优秀的 亮度与HDR首先，HDR代表(High-Dynamic Range) 和普通的SDR相比，HDR可以提供更多的动态范围和图像细节，能够在显示器中更真实的还原视觉效果； 常见的HDR10、HDR400开启之后效果不是很明显，是因为这两个标准只是一个入门的标准；2000元以上的显示器讲HDR才有意义，600是标配。 无频闪市面上主流的显示器是LCD显示器，其发光原理是提用过电能刺激晶体分子来发光。通过电能刺激发光，在没有电能刺激的时候熄灭，这种调光技术称之为PWM调光。 在屏幕亮、灭的过程中，灭屏状态持续时间越长，屏幕眼睛的观感就是亮度越低，点亮的时间越长，灭屏时间就相应减少，屏幕眼睛的观感就是亮度越高。 在这种频繁的切换中，对人眼造成的不利影响的可能性就越大； 而解决这个问题的方法就是“DC调光”，其工作的原理是通过提升或降低电路的功率来改变亮度，如果想要护眼请一定认证无频闪和DC调光的显示器； 防撕裂技术（高刷电竞屏） 带英伟达 G-SYNC &#x2F;AMD FreeSync技术 个人购买感受（2022.10.31 4K60HZ飞利浦27E1N5900E） 京东最后1449拿下。京东方N20面板，4K算低端，竞品AOC U27N3C 1699元同面板，接口更多、KVM功能，但基本用不上，所以没买。主要看重飞利浦、戴尔这类牌子的售后更好，和屏幕质量更适合大众、品控问题较少。 非高端屏日常使用8bit和10bit差距不大，办公屏的话标配10bit没问题，显示器成本不在这里，8还是10都可以 厂商的调教、售后、屏幕质量更重要，一线大品牌会贵一点，主屏建议买大品牌，副品牌可以买主打性价比的二三线 便宜的显示器面板会差一点，比如用不是最新一代的。二三线主打性价比的显示器面板会用好点的，但色彩调节、品控几乎就等于没有，用起来屏幕可能会刺眼不舒服，等于是买面板的价格。 办公打代码之类60HZ没有任何问题，3A体验也不差，2019年英伟达已经有像素点四合一技术，4K开1080P打3A完全不糊。FPS、竞速或者讲究响应速度的游戏更需要高刷。 显示器USB接口需要用USB上行接电脑之后才能用，主要是面向笔记本设计当拓展坞用，全功能Type-C接笔记本和手机可以传输数据和充电投屏，90W和65W可以为轻薄笔记本充电，游戏本功率原因别指望能充上，支持PD接口也可以充电。台式机其实没必要考虑接口，没有USB上行就只能插电灯。 按价格分，越级的产品一般会在某些地方偷工减料，比如2000元入门Mini LED的联合创新M2U，背光分区才几百个，标准3-4k的都是上千个分区，这种产品等于买个名字，体验体验一下。这是需要注意的。 下一台显示器应该怎么选 想体验顶级的黑白对比度、色彩就上标准价位的Mini LED，本质也是LCD屏幕，iPad产品标准屏幕体验。 我们这类用户不建议OLED，会烧屏而且高频闪，等几年后Micro LED落地并成熟、有钱再买更好的。 毕业之后真有钱就4K高刷，2022年价位3-4K，到时候价格应该2-3K可以拿下。日常4k高刷绝对够用了，以后也是打代码办公居多，顺便兼顾游戏了。 2022年双十一4k高刷价位 2K 高刷主要是4K过渡期为了游戏而设，以后应不考虑这个。","categories":[],"tags":[]},{"title":"SpringSecurity-从入门到精通","slug":"SpringSecurity-从入门到精通","date":"2022-09-20T07:40:01.000Z","updated":"2022-09-20T13:41:19.083Z","comments":true,"path":"2022/09/20/SpringSecurity-从入门到精通/","link":"","permalink":"http://example.com/2022/09/20/SpringSecurity-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","excerpt":"","text":"SpringSecurity从入门到精通课程介绍 0. 简介​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​ 我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 12345678@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller 12345678910111213import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​ 必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​ ①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​ ②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​ ①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 1234567891011121314151617&lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; 12345678910111213141516171819202122232425262728293031import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.fasterxml.jackson.annotation.JsonInclude;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; 12345678910111213141516171819202122232425262728import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​ 我们先创建一个用户表， 建表语句如下： 123456789101112131415161718CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 123456789&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 123456spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 1类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 12345678@SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 123456789101112131415/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 12345678910111213141516171819202122232425/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​ 实际项目中我们不会把密码明文存储在数据库中。 ​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 123456789101112@RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; ​ 12345678910111213141516171819202122232425262728@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​ 使用userid去redis中获取对应的LoginUser对象。 ​ 然后封装Authentication对象存入SecurityContextHolder 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 ​ 3.1 授权基本流程​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​ 然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​ 但是要使用它我们需要先开启相关配置。 1@EnableGlobalMethodSecurity(prePostEnabled = true) ​ 然后就可以使用对应的注解。@PreAuthorize 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​ 我们先直接把权限信息写死封装到UserDetails中进行测试。 ​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 1234567891011SELECT DISTINCT m.`perms`FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE user_id = 2 AND r.`status` = 0 AND m.`status` = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​ 我们只需要根据用户id去查询到其所对应的权限信息即可。 ​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 1234567891011import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​ 在application.yml中配置mapperXML文件的位置 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 1234567891011121314151617181920212223242526/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 1234567891011@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​ ​ 先注入对应的处理器 12345@Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​ 然后我们可以使用HttpSecurity对象的方法去配置。 12http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 5. 跨域​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​ 所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 12345678910111213141516171819@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题其它权限校验方法​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​ ​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 1234@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 自定义权限校验方法​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 123456789101112@Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 12345@RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 基于配置的权限控制​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; CSRF​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​ https://blog.csdn.net/freeking101/article/details/86537087 ​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 认证成功处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。 123456789@Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; 1234567891011121314@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 认证失败处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。 1234567@Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; 123456789101112131415161718192021@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 登出成功处理器12345678@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 其他认证方案畅想7. 源码讲解​ 投票过50更新源码讲解","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2022-09-14T07:40:01.000Z","updated":"2022-09-15T12:17:42.685Z","comments":true,"path":"2022/09/14/my-first-blog/","link":"","permalink":"http://example.com/2022/09/14/my-first-blog/","excerpt":"","text":"开启三个线程：1，从缓冲区读入帧，2、对每一帧分析识别装甲板灯条 3、读取机器人电控发来的信息 1 提取红蓝通道，进行图像形态学操作（二值化、膨胀、腐蚀）检测轮廓，找到符合要求的装甲板形态的图像区域用roi框出来，并且筛选掉与水平方向角度过大的roi框。 2 筛选符合两灯条的特征，两条灯条不平行、相隔距离超过阈值等情况筛选掉，并通过灯条的宽高比例，中心点的位置距离判断是否是所需要的灯条。最后用稍大一点的roi框出来，并确保不会越出图片的边界（使用的应该是rmuc代码） 3 对识别的灯条识别四个外角点，计算全图中的坐标，为PNP作准备 4 然后做PNP求解:相机坐标系相对于世界坐标系的位姿，（四元数转欧拉角），从而得到机器人云台到目标装甲板灯条的方位和相对距离，计算出偏航角和俯仰角，也就是yaw和pitch。 https://blog.csdn.net/weixin_44197735/article/details/124341862 5 最后通过这些数据把相机坐标系通过平移到枪管口坐标系做重力下坠模型或者平移到云台做位姿估计。","categories":[],"tags":[]},{"title":"JWT实战","slug":"JWT 实战教程","date":"2022-07-20T01:00:01.000Z","updated":"2022-09-15T15:47:29.718Z","comments":true,"path":"2022/07/20/JWT 实战教程/","link":"","permalink":"http://example.com/2022/07/20/JWT%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/","excerpt":"","text":"JWT 实战教程 1.什么是JWTJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public&#x2F;private key pair using RSA or ECDSA. ​ —[摘自官网] 123456# 1.翻译- 官网地址: https://jwt.io/introduction/- 翻译: jsonwebtoken（JWT）是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名# 2.通俗解释- JWT简称JSON Web Token,也就是通过JSON形式作为Web应用中的令牌,用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。 2.JWT能做什么12345# 1.授权- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。# 2.信息交换- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。 3.为什么是JWT基于传统的Session认证1234# 1.认证方式- 我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。# 2.认证流程 123456789# 3.暴露问题- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。- 4.在前后端分离系统中就更加痛苦:如下图所示 也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务 器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻 击）攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是 sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。 不方便集群应用。 基于JWT认证 1234567891011121314151617181920# 1.认证流程- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。# 2.jwt优势- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。- 不需要在服务端保存会话信息，特别适用于分布式微服务。 4.JWT的结构是什么?1234567token string ====&gt; header.payload.singnature token # 1.令牌组成- 1.标头(Header)- 2.有效载荷(Payload)- 3.签名(Signature)- 因此，JWT通常如下所示:xxxxx.yyyyy.zzzzz Header.Payload.Signature 1234# 2.Header- 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。- 注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 12# 3.Payload- 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 123456789101112# 4.Signature- 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过- 如: HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret);# 签名目的- 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。# 信息安全问题- 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？- 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。 123456# 5.放在一起- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。- 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快- 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 5.使用JWT1# 1.引入依赖 123456&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 1# 2.生成token 123456789Calendar instance = Calendar.getInstance();instance.add(Calendar.SECOND, 90);//生成令牌String token = JWT.create() .withClaim(&quot;username&quot;, &quot;张三&quot;)//设置自定义用户名 .withExpiresAt(instance.getTime())//设置过期时间 .sign(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;));//设置签名 保密 复杂//输出令牌System.out.println(token); 12- 生成结果eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg 1# 3.根据令牌和签名解析数据 1234JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;)).build();DecodedJWT decodedJWT = jwtVerifier.verify(token);System.out.println(&quot;用户名: &quot; + decodedJWT.getClaim(&quot;username&quot;).asString());System.out.println(&quot;过期时间: &quot;+decodedJWT.getExpiresAt()); 12345# 4.常见异常信息- SignatureVerificationException: 签名不一致异常- TokenExpiredException: 令牌过期异常- AlgorithmMismatchException: 算法不匹配异常- InvalidClaimException: 失效的payload异常 6.封装工具类12345678910111213141516171819202122232425262728293031323334public class JWTUtils &#123; private static String TOKEN = &quot;token!Q@W3e4r&quot;; /** * 生成token * @param map //传入payload * @return 返回token */ public static String getToken(Map&lt;String,String&gt; map)&#123; JWTCreator.Builder builder = JWT.create(); map.forEach((k,v)-&gt;&#123; builder.withClaim(k,v); &#125;); Calendar instance = Calendar.getInstance(); instance.add(Calendar.SECOND,7); builder.withExpiresAt(instance.getTime()); return builder.sign(Algorithm.HMAC256(TOKEN)).toString(); &#125; /** * 验证token * @param token * @return */ public static void verify(String token)&#123; JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125; /** * 获取token中payload * @param token * @return */ public static DecodedJWT getToken(String token)&#123; return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125;&#125; 7.整合springboot123# 0.搭建springboot+mybatis+jwt环境- 引入依赖- 编写配置 12345678910111213141516171819202122232425262728293031323334&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt; 12345678910111213server.port=8989spring.application.name=jwtspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootmybatis.type-aliases-package=com.baizhi.entitymybatis.mapper-locations=classpath:com/baizhi/mapper/*.xmllogging.level.com.baizhi.dao=debug 12# 1.开发数据库- 这里采用最简单的表结构验证JWT使用 ![image-20200805212226422](JWT 实战教程.assets&#x2F;image-20200805212226422.png) 1234567DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(80) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(40) DEFAULT NULL COMMENT &#x27;用户密码&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 1# 2.开发entity 1234567@Data@Accessors(chain=true)public class User &#123; private String id; private String name; private String password;&#125; 1# 3.开发DAO接口和mapper.xml 1234@Mapperpublic interface UserDAO &#123; User login(User user);&#125; 123456&lt;mapper namespace=&quot;com.baizhi.dao.UserDAO&quot;&gt; &lt;!--这里就写的简单点了毕竟不是重点--&gt; &lt;select id=&quot;login&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; select * from user where name=#&#123;name&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 1# 4.开发Service 接口以及实现类 123public interface UserService &#123; User login(User user);//登录接口&#125; 123456789101112131415@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDAO userDAO; @Override @Transactional(propagation = Propagation.SUPPORTS) public User login(User user) &#123; User userDB = userDAO.login(user); if(userDB!=null)&#123; return userDB; &#125; throw new RuntimeException(&quot;登录失败~~&quot;); &#125;&#125; 1# 5.开发controller 123456789101112131415161718192021222324252627@RestController@Slf4jpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/user/login&quot;) public Map&lt;String,Object&gt; login(User user) &#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); log.info(&quot;用户名: [&#123;&#125;]&quot;, user.getName()); log.info(&quot;密码: [&#123;&#125;]&quot;, user.getPassword()); try &#123; User userDB = userService.login(user); Map&lt;String, String&gt; map = new HashMap&lt;&gt;();//用来存放payload map.put(&quot;id&quot;,userDB.getId()); map.put(&quot;username&quot;, userDB.getName()); String token = JWTUtils.getToken(map); result.put(&quot;state&quot;,true); result.put(&quot;msg&quot;,&quot;登录成功!!!&quot;); result.put(&quot;token&quot;,token); //成功返回token信息 &#125; catch (Exception e) &#123; e.printStackTrace(); result.put(&quot;state&quot;,&quot;false&quot;); result.put(&quot;msg&quot;,e.getMessage()); &#125; return result; &#125;&#125; 1# 6.数据库添加测试数据启动项目 1# 7.通过postman模拟登录失败 1# 8.通过postman模拟登录成功 1# 9.编写测试接口 1234567891011121314151617181920212223@PostMapping(&quot;/test/test&quot;)public Map&lt;String, Object&gt; test(String token) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); map.put(&quot;msg&quot;, &quot;验证通过~~~&quot;); map.put(&quot;state&quot;, true); &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; return map;&#125; 1# 10.通过postman请求接口 123# 11.问题?- 使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化- 使用拦截器进行优化 1234567891011121314151617181920212223242526@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(&quot;token&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); return true; &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; String json = new ObjectMapper().writeValueAsString(map); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().println(json); return false;&#125; 123456789@Componentpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtTokenInterceptor()). excludePathPatterns(&quot;/user/**&quot;) .addPathPatterns(&quot;/**&quot;); &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}