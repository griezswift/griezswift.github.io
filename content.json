{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"my first blog","slug":"my-first-blog","date":"2022-09-14T07:40:01.000Z","updated":"2022-09-15T12:17:42.685Z","comments":true,"path":"2022/09/14/my-first-blog/","link":"","permalink":"http://example.com/2022/09/14/my-first-blog/","excerpt":"","text":"开启三个线程：1，从缓冲区读入帧，2、对每一帧分析识别装甲板灯条 3、读取机器人电控发来的信息 1 提取红蓝通道，进行图像形态学操作（二值化、膨胀、腐蚀）检测轮廓，找到符合要求的装甲板形态的图像区域用roi框出来，并且筛选掉与水平方向角度过大的roi框。 2 筛选符合两灯条的特征，两条灯条不平行、相隔距离超过阈值等情况筛选掉，并通过灯条的宽高比例，中心点的位置距离判断是否是所需要的灯条。最后用稍大一点的roi框出来，并确保不会越出图片的边界（使用的应该是rmuc代码） 3 对识别的灯条识别四个外角点，计算全图中的坐标，为PNP作准备 4 然后做PNP求解:相机坐标系相对于世界坐标系的位姿，（四元数转欧拉角），从而得到机器人云台到目标装甲板灯条的方位和相对距离，计算出偏航角和俯仰角，也就是yaw和pitch。 https://blog.csdn.net/weixin_44197735/article/details/124341862 5 最后通过这些数据把相机坐标系通过平移到枪管口坐标系做重力下坠模型或者平移到云台做位姿估计。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-09-14T05:24:44.822Z","updated":"2022-09-14T05:24:44.822Z","comments":true,"path":"2022/09/14/hello-world/","link":"","permalink":"http://example.com/2022/09/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"JWT 实战教程","date":"2022-07-22T04:36:07.308Z","updated":"2022-07-21T12:47:24.470Z","comments":true,"path":"2022/07/22/JWT 实战教程/","link":"","permalink":"http://example.com/2022/07/22/JWT%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/","excerpt":"","text":"JWT 实战教程![image-20200726102546868](JWT 实战教程.assets&#x2F;image-20200726102546868.png) 1.什么是JWTJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public&#x2F;private key pair using RSA or ECDSA. ​ —[摘自官网] 123456# 1.翻译- 官网地址: https://jwt.io/introduction/- 翻译: jsonwebtoken（JWT）是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名# 2.通俗解释- JWT简称JSON Web Token,也就是通过JSON形式作为Web应用中的令牌,用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。 2.JWT能做什么12345# 1.授权- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。# 2.信息交换- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。 3.为什么是JWT基于传统的Session认证1234# 1.认证方式- 我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。# 2.认证流程 ![image-20200726103959013](JWT 实战教程.assets&#x2F;image-20200726103959013.png) 123456789# 3.暴露问题- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。- 4.在前后端分离系统中就更加痛苦:如下图所示 也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务 器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻 击）攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是 sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。 不方便集群应用。 ![image-20200804212240422](JWT 实战教程.assets&#x2F;image-20200804212240422.png) 基于JWT认证![image-20200726183248298](JWT 实战教程.assets&#x2F;image-20200726183248298.png) 1234567891011121314151617181920# 1.认证流程- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。# 2.jwt优势- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。- 不需要在服务端保存会话信息，特别适用于分布式微服务。 4.JWT的结构是什么?1234567token string ====&gt; header.payload.singnature token # 1.令牌组成- 1.标头(Header)- 2.有效载荷(Payload)- 3.签名(Signature)- 因此，JWT通常如下所示:xxxxx.yyyyy.zzzzz Header.Payload.Signature 1234# 2.Header- 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。- 注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 12# 3.Payload- 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 123456789101112# 4.Signature- 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过- 如: HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret);# 签名目的- 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。# 信息安全问题- 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？- 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。 ![image-20200726181136113](JWT 实战教程.assets&#x2F;image-20200726181136113.png) 123456# 5.放在一起- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。- 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快- 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 ![image-20200726124257203](JWT 实战教程.assets&#x2F;image-20200726124257203.png) 5.使用JWT1# 1.引入依赖 123456&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 1# 2.生成token 123456789Calendar instance = Calendar.getInstance();instance.add(Calendar.SECOND, 90);//生成令牌String token = JWT.create() .withClaim(&quot;username&quot;, &quot;张三&quot;)//设置自定义用户名 .withExpiresAt(instance.getTime())//设置过期时间 .sign(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;));//设置签名 保密 复杂//输出令牌System.out.println(token); 12- 生成结果eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg 1# 3.根据令牌和签名解析数据 1234JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;)).build();DecodedJWT decodedJWT = jwtVerifier.verify(token);System.out.println(&quot;用户名: &quot; + decodedJWT.getClaim(&quot;username&quot;).asString());System.out.println(&quot;过期时间: &quot;+decodedJWT.getExpiresAt()); 12345# 4.常见异常信息- SignatureVerificationException: 签名不一致异常- TokenExpiredException: 令牌过期异常- AlgorithmMismatchException: 算法不匹配异常- InvalidClaimException: 失效的payload异常 ![image-20200805184517282](JWT 实战教程.assets&#x2F;image-20200805184517282.png) 6.封装工具类12345678910111213141516171819202122232425262728293031323334public class JWTUtils &#123; private static String TOKEN = &quot;token!Q@W3e4r&quot;; /** * 生成token * @param map //传入payload * @return 返回token */ public static String getToken(Map&lt;String,String&gt; map)&#123; JWTCreator.Builder builder = JWT.create(); map.forEach((k,v)-&gt;&#123; builder.withClaim(k,v); &#125;); Calendar instance = Calendar.getInstance(); instance.add(Calendar.SECOND,7); builder.withExpiresAt(instance.getTime()); return builder.sign(Algorithm.HMAC256(TOKEN)).toString(); &#125; /** * 验证token * @param token * @return */ public static void verify(String token)&#123; JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125; /** * 获取token中payload * @param token * @return */ public static DecodedJWT getToken(String token)&#123; return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125;&#125; 7.整合springboot123# 0.搭建springboot+mybatis+jwt环境- 引入依赖- 编写配置 12345678910111213141516171819202122232425262728293031323334&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt; 12345678910111213server.port=8989spring.application.name=jwtspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootmybatis.type-aliases-package=com.baizhi.entitymybatis.mapper-locations=classpath:com/baizhi/mapper/*.xmllogging.level.com.baizhi.dao=debug 12# 1.开发数据库- 这里采用最简单的表结构验证JWT使用 ![image-20200805212226422](JWT 实战教程.assets&#x2F;image-20200805212226422.png) 1234567DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(80) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(40) DEFAULT NULL COMMENT &#x27;用户密码&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 1# 2.开发entity 1234567@Data@Accessors(chain=true)public class User &#123; private String id; private String name; private String password;&#125; ![image-20200805213539471](JWT 实战教程.assets&#x2F;image-20200805213539471.png) 1# 3.开发DAO接口和mapper.xml 1234@Mapperpublic interface UserDAO &#123; User login(User user);&#125; ![image-20200805213603655](JWT 实战教程.assets&#x2F;image-20200805213603655.png) 123456&lt;mapper namespace=&quot;com.baizhi.dao.UserDAO&quot;&gt; &lt;!--这里就写的简单点了毕竟不是重点--&gt; &lt;select id=&quot;login&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; select * from user where name=#&#123;name&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; ![image-20200805213628252](JWT 实战教程.assets&#x2F;image-20200805213628252.png) 1# 4.开发Service 接口以及实现类 123public interface UserService &#123; User login(User user);//登录接口&#125; ![image-20200805213648147](JWT 实战教程.assets&#x2F;image-20200805213648147.png) 123456789101112131415@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDAO userDAO; @Override @Transactional(propagation = Propagation.SUPPORTS) public User login(User user) &#123; User userDB = userDAO.login(user); if(userDB!=null)&#123; return userDB; &#125; throw new RuntimeException(&quot;登录失败~~&quot;); &#125;&#125; ![image-20200805213704965](JWT 实战教程.assets&#x2F;image-20200805213704965.png) 1# 5.开发controller 123456789101112131415161718192021222324252627@RestController@Slf4jpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/user/login&quot;) public Map&lt;String,Object&gt; login(User user) &#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); log.info(&quot;用户名: [&#123;&#125;]&quot;, user.getName()); log.info(&quot;密码: [&#123;&#125;]&quot;, user.getPassword()); try &#123; User userDB = userService.login(user); Map&lt;String, String&gt; map = new HashMap&lt;&gt;();//用来存放payload map.put(&quot;id&quot;,userDB.getId()); map.put(&quot;username&quot;, userDB.getName()); String token = JWTUtils.getToken(map); result.put(&quot;state&quot;,true); result.put(&quot;msg&quot;,&quot;登录成功!!!&quot;); result.put(&quot;token&quot;,token); //成功返回token信息 &#125; catch (Exception e) &#123; e.printStackTrace(); result.put(&quot;state&quot;,&quot;false&quot;); result.put(&quot;msg&quot;,e.getMessage()); &#125; return result; &#125;&#125; ![image-20200805214235426](JWT 实战教程.assets&#x2F;image-20200805214235426.png) 1# 6.数据库添加测试数据启动项目 ![image-20200805214324868](JWT 实战教程.assets&#x2F;image-20200805214324868.png) ![image-20200805214424786](JWT 实战教程.assets&#x2F;image-20200805214424786.png) 1# 7.通过postman模拟登录失败 ![image-20200805214610668](JWT 实战教程.assets&#x2F;image-20200805214610668.png) 1# 8.通过postman模拟登录成功 ![image-20200805214749469](JWT 实战教程.assets&#x2F;image-20200805214749469.png) 1# 9.编写测试接口 1234567891011121314151617181920212223@PostMapping(&quot;/test/test&quot;)public Map&lt;String, Object&gt; test(String token) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); map.put(&quot;msg&quot;, &quot;验证通过~~~&quot;); map.put(&quot;state&quot;, true); &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; return map;&#125; ![image-20200805215119590](JWT 实战教程.assets&#x2F;image-20200805215119590.png) 1# 10.通过postman请求接口 ![image-20200805215337303](JWT 实战教程.assets&#x2F;image-20200805215337303.png) ![image-20200805215451442](JWT 实战教程.assets&#x2F;image-20200805215451442.png) 123# 11.问题?- 使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化- 使用拦截器进行优化 1234567891011121314151617181920212223242526@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(&quot;token&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); return true; &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; String json = new ObjectMapper().writeValueAsString(map); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().println(json); return false;&#125; 123456789@Componentpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtTokenInterceptor()). excludePathPatterns(&quot;/user/**&quot;) .addPathPatterns(&quot;/**&quot;); &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}