{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"SpringSecurity-从入门到精通","slug":"SpringSecurity-从入门到精通","date":"2022-09-20T07:40:01.000Z","updated":"2022-09-20T13:41:19.083Z","comments":true,"path":"2022/09/20/SpringSecurity-从入门到精通/","link":"","permalink":"http://example.com/2022/09/20/SpringSecurity-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","excerpt":"","text":"SpringSecurity从入门到精通课程介绍 0. 简介​ Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。 ​ 一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。 ​ 一般Web应用的需要进行认证和授权。 ​ 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 ​ 授权：经过认证后判断当前用户是否有权限进行某个操作 ​ 而认证和授权也是SpringSecurity作为安全框架的核心功能。 1. 快速入门1.1 准备工作​ 我们先要搭建一个简单的SpringBoot工程 ① 设置父工程 添加依赖 12345678910111213141516&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ② 创建启动类 12345678@SpringBootApplicationpublic class SecurityApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SecurityApplication.class,args); &#125;&#125; ③ 创建Controller 12345678910111213import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 1.2 引入SpringSecurity​ 在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; ​ 引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。 ​ 必须登陆之后才能对接口进行访问。 2. 认证2.1 登陆校验流程 2.2 原理初探​ 想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。 2.2.1 SpringSecurity完整流程​ SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 ​ 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 ExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 FilterSecurityInterceptor：负责权限校验的过滤器。 ​ ​ 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 2.2.2 认证流程详解 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 2.3 解决问题2.3.1 思路分析登录 ​ ①自定义登录接口 ​ 调用ProviderManager的方法进行认证 如果认证通过生成jwt ​ 把用户信息存入redis中 ​ ②自定义UserDetailsService ​ 在这个实现类中去查询数据库 校验： ​ ①定义Jwt认证过滤器 ​ 获取token ​ 解析token获取其中的userid ​ 从redis中获取用户信息 ​ 存入SecurityContextHolder 2.3.2 准备工作①添加依赖 1234567891011121314151617&lt;!--redis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--fastjson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.33&lt;/version&gt;&lt;/dependency&gt;&lt;!--jwt依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt;&lt;/dependency&gt; ② 添加Redis相关配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.type.TypeFactory;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.SerializationException;import com.alibaba.fastjson.parser.ParserConfig;import org.springframework.util.Assert;import java.nio.charset.Charset;/** * Redis使用FastJson序列化 * * @author sg */public class FastJsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt;&#123; public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); private Class&lt;T&gt; clazz; static &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); &#125; public FastJsonRedisSerializer(Class&lt;T&gt; clazz) &#123; super(); this.clazz = clazz; &#125; @Override public byte[] serialize(T t) throws SerializationException &#123; if (t == null) &#123; return new byte[0]; &#125; return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET); &#125; @Override public T deserialize(byte[] bytes) throws SerializationException &#123; if (bytes == null || bytes.length &lt;= 0) &#123; return null; &#125; String str = new String(bytes, DEFAULT_CHARSET); return JSON.parseObject(str, clazz); &#125; protected JavaType getJavaType(Class&lt;?&gt; clazz) &#123; return TypeFactory.defaultInstance().constructType(clazz); &#125;&#125; 12345678910111213141516171819202122232425262728293031import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123; @Bean @SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(connectionFactory); FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class); // 使用StringRedisSerializer来序列化和反序列化redis的key值 template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(serializer); // Hash的key也采用StringRedisSerializer的序列化方式 template.setHashKeySerializer(new StringRedisSerializer()); template.setHashValueSerializer(serializer); template.afterPropertiesSet(); return template; &#125;&#125; ③ 响应类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.fasterxml.jackson.annotation.JsonInclude;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@JsonInclude(JsonInclude.Include.NON_NULL)public class ResponseResult&lt;T&gt; &#123; /** * 状态码 */ private Integer code; /** * 提示信息，如果有错误时，前端可以获取该字段进行提示 */ private String msg; /** * 查询到的结果数据， */ private T data; public ResponseResult(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; public ResponseResult(Integer code, T data) &#123; this.code = code; this.data = data; &#125; public Integer getCode() &#123; return code; &#125; public void setCode(Integer code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public ResponseResult(Integer code, String msg, T data) &#123; this.code = code; this.msg = msg; this.data = data; &#125;&#125; ④工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Base64;import java.util.Date;import java.util.UUID;/** * JWT工具类 */public class JwtUtil &#123; //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = &quot;sangeng&quot;; public static String getUUID()&#123; String token = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;); return token; &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @return */ public static String createJWT(String subject) &#123; JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间 return builder.compact(); &#125; /** * 生成jtw * @param subject token中要存放的数据（json格式） * @param ttlMillis token超时时间 * @return */ public static String createJWT(String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间 return builder.compact(); &#125; private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123; SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; SecretKey secretKey = generalKey(); long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null)&#123; ttlMillis=JwtUtil.JWT_TTL; &#125; long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); return Jwts.builder() .setId(uuid) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(&quot;sg&quot;) // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate); &#125; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) &#123; JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间 return builder.compact(); &#125; public static void main(String[] args) throws Exception &#123; String token = &quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;; Claims claims = parseJWT(token); System.out.println(claims); &#125; /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() &#123; byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;); return key; &#125; /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception &#123; SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230import java.util.*;import java.util.concurrent.TimeUnit;@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123; @Autowired public RedisTemplate redisTemplate; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 */ public &lt;T&gt; void setCacheObject(final String key, final T value) &#123; redisTemplate.opsForValue().set(key, value); &#125; /** * 缓存基本的对象，Integer、String、实体类等 * * @param key 缓存的键值 * @param value 缓存的值 * @param timeout 时间 * @param timeUnit 时间颗粒度 */ public &lt;T&gt; void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit) &#123; redisTemplate.opsForValue().set(key, value, timeout, timeUnit); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout) &#123; return expire(key, timeout, TimeUnit.SECONDS); &#125; /** * 设置有效时间 * * @param key Redis键 * @param timeout 超时时间 * @param unit 时间单位 * @return true=设置成功；false=设置失败 */ public boolean expire(final String key, final long timeout, final TimeUnit unit) &#123; return redisTemplate.expire(key, timeout, unit); &#125; /** * 获得缓存的基本对象。 * * @param key 缓存键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; T getCacheObject(final String key) &#123; ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue(); return operation.get(key); &#125; /** * 删除单个对象 * * @param key */ public boolean deleteObject(final String key) &#123; return redisTemplate.delete(key); &#125; /** * 删除集合对象 * * @param collection 多个对象 * @return */ public long deleteObject(final Collection collection) &#123; return redisTemplate.delete(collection); &#125; /** * 缓存List数据 * * @param key 缓存的键值 * @param dataList 待缓存的List数据 * @return 缓存的对象 */ public &lt;T&gt; long setCacheList(final String key, final List&lt;T&gt; dataList) &#123; Long count = redisTemplate.opsForList().rightPushAll(key, dataList); return count == null ? 0 : count; &#125; /** * 获得缓存的list对象 * * @param key 缓存的键值 * @return 缓存键值对应的数据 */ public &lt;T&gt; List&lt;T&gt; getCacheList(final String key) &#123; return redisTemplate.opsForList().range(key, 0, -1); &#125; /** * 缓存Set * * @param key 缓存键值 * @param dataSet 缓存的数据 * @return 缓存数据的对象 */ public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(final String key, final Set&lt;T&gt; dataSet) &#123; BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key); Iterator&lt;T&gt; it = dataSet.iterator(); while (it.hasNext()) &#123; setOperation.add(it.next()); &#125; return setOperation; &#125; /** * 获得缓存的set * * @param key * @return */ public &lt;T&gt; Set&lt;T&gt; getCacheSet(final String key) &#123; return redisTemplate.opsForSet().members(key); &#125; /** * 缓存Map * * @param key * @param dataMap */ public &lt;T&gt; void setCacheMap(final String key, final Map&lt;String, T&gt; dataMap) &#123; if (dataMap != null) &#123; redisTemplate.opsForHash().putAll(key, dataMap); &#125; &#125; /** * 获得缓存的Map * * @param key * @return */ public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(final String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * 往Hash中存入数据 * * @param key Redis键 * @param hKey Hash键 * @param value 值 */ public &lt;T&gt; void setCacheMapValue(final String key, final String hKey, final T value) &#123; redisTemplate.opsForHash().put(key, hKey, value); &#125; /** * 获取Hash中的数据 * * @param key Redis键 * @param hKey Hash键 * @return Hash中的对象 */ public &lt;T&gt; T getCacheMapValue(final String key, final String hKey) &#123; HashOperations&lt;String, String, T&gt; opsForHash = redisTemplate.opsForHash(); return opsForHash.get(key, hKey); &#125; /** * 删除Hash中的数据 * * @param key * @param hkey */ public void delCacheMapValue(final String key, final String hkey) &#123; HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.delete(key, hkey); &#125; /** * 获取多个Hash中的数据 * * @param key Redis键 * @param hKeys Hash键集合 * @return Hash对象集合 */ public &lt;T&gt; List&lt;T&gt; getMultiCacheMapValue(final String key, final Collection&lt;Object&gt; hKeys) &#123; return redisTemplate.opsForHash().multiGet(key, hKeys); &#125; /** * 获得缓存的基本对象列表 * * @param pattern 字符串前缀 * @return 对象列表 */ public Collection&lt;String&gt; keys(final String pattern) &#123; return redisTemplate.keys(pattern); &#125;&#125; 12345678910111213141516171819202122232425262728import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; ⑤实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.Serializable;import java.util.Date;/** * 用户表(User)实体类 * * @author 三更 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private static final long serialVersionUID = -40356785423868312L; /** * 主键 */ private Long id; /** * 用户名 */ private String userName; /** * 昵称 */ private String nickName; /** * 密码 */ private String password; /** * 账号状态（0正常 1停用） */ private String status; /** * 邮箱 */ private String email; /** * 手机号 */ private String phonenumber; /** * 用户性别（0男，1女，2未知） */ private String sex; /** * 头像 */ private String avatar; /** * 用户类型（0管理员，1普通用户） */ private String userType; /** * 创建人的用户id */ private Long createBy; /** * 创建时间 */ private Date createTime; /** * 更新人 */ private Long updateBy; /** * 更新时间 */ private Date updateTime; /** * 删除标志（0代表未删除，1代表已删除） */ private Integer delFlag;&#125; 2.3.3 实现2.3.3.1 数据库校验用户​ 从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。 准备工作​ 我们先创建一个用户表， 建表语句如下： 123456789101112131415161718CREATE TABLE `sys_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` VARCHAR(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` CHAR(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` VARCHAR(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` VARCHAR(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` CHAR(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` VARCHAR(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` CHAR(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` INT(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27; ​ 引入MybatisPuls和mysql驱动的依赖 123456789&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; ​ 配置数据库信息 123456spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver ​ 定义Mapper接口 12public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; ​ 修改User实体类 1类名上加@TableName(value = &quot;sys_user&quot;) ,id字段上加 @TableId ​ 配置Mapper扫描 12345678@SpringBootApplication@MapperScan(&quot;com.sangeng.mapper&quot;)public class SimpleSecurityApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class); System.out.println(run); &#125;&#125; ​ 添加junit依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; ​ 测试MP是否能正常使用 123456789101112131415/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@SpringBootTestpublic class MapperTest &#123; @Autowired private UserMapper userMapper; @Test public void testUserMapper()&#123; List&lt;User&gt; users = userMapper.selectList(null); System.out.println(users); &#125;&#125; 核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息 12345678910111213141516171819202122232425/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //根据用户名查询用户信息 LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); //如果查询不到数据就通过抛出异常来给出提示 if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 //封装成UserDetails对象返回 return new LoginUser(user); &#125;&#125; 因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructor@AllArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return null; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如 这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。 2.3.3.2 密码加密存储​ 实际项目中我们不会把密码明文存储在数据库中。 ​ 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 ​ 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。 ​ 我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 ​ 我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125;&#125; 2.3.3.3 登陆接口​ 接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。 ​ 在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。 ​ 认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。 123456789101112@RestControllerpublic class LoginController &#123; @Autowired private LoginServcie loginServcie; @PostMapping(&quot;/user/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginServcie.login(user); &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; ​ 12345678910111213141516171819202122232425262728@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125;&#125; 2.3.3.4 认证过滤器​ 我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。 ​ 使用userid去redis中获取对应的LoginUser对象。 ​ 然后封装Authentication对象存入SecurityContextHolder 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private RedisCache redisCache; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; //获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; //放行 filterChain.doFilter(request, response); return; &#125; //解析token String userid; try &#123; Claims claims = JwtUtil.parseJWT(token); userid = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; //从redis中获取用户信息 String redisKey = &quot;login:&quot; + userid; LoginUser loginUser = redisCache.getCacheObject(redisKey); if(Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; //存入SecurityContextHolder //TODO 获取权限信息封装到Authentication中 UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser,null,null); SecurityContextHolder.getContext().setAuthentication(authenticationToken); //放行 filterChain.doFilter(request, response); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Bean public PasswordEncoder passwordEncoder()&#123; return new BCryptPasswordEncoder(); &#125; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //把token校验过滤器添加到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 2.3.3.5 退出登陆​ 我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class LoginServiceImpl implements LoginServcie &#123; @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisCache redisCache; @Override public ResponseResult login(User user) &#123; UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword()); Authentication authenticate = authenticationManager.authenticate(authenticationToken); if(Objects.isNull(authenticate))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //使用userid生成token LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); //authenticate存入redis redisCache.setCacheObject(&quot;login:&quot;+userId,loginUser); //把token响应给前端 HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;,jwt); return new ResponseResult(200,&quot;登陆成功&quot;,map); &#125; @Override public ResponseResult logout() &#123; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); Long userid = loginUser.getUser().getId(); redisCache.deleteObject(&quot;login:&quot;+userid); return new ResponseResult(200,&quot;退出成功&quot;); &#125;&#125; 3. 授权3.0 权限系统的作用​ 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 ​ 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 ​ 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 ​ 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 ​ 3.1 授权基本流程​ 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。 ​ 所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。 ​ 然后设置我们的资源所需要的权限即可。 3.2 授权实现3.2.1 限制访问资源所需权限​ SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。 ​ 但是要使用它我们需要先开启相关配置。 1@EnableGlobalMethodSecurity(prePostEnabled = true) ​ 然后就可以使用对应的注解。@PreAuthorize 123456789@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;) public String hello()&#123; return &quot;hello&quot;; &#125;&#125; 3.2.2 封装权限信息​ 我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。 ​ 我们先直接把权限信息写死封装到UserDetails中进行测试。 ​ 我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.sangeng.domain;import com.alibaba.fastjson.annotation.JSONField;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user,List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JSONField(serialize = false) private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; ​ LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sangeng.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;import com.sangeng.domain.LoginUser;import com.sangeng.domain.User;import com.sangeng.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Objects;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; //TODO 根据用户查询权限信息 添加到LoginUser中 List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,list); &#125;&#125; 3.2.3 从数据库查询权限信息3.2.3.1 RBAC权限模型​ RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 ​ 3.2.3.2 准备工作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788CREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;USE `sg_security`;/*Table structure for table `sys_menu` */DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint(20) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(20) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;菜单表&#x27;;/*Table structure for table `sys_role` */DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(128) DEFAULT NULL, `role_key` varchar(100) DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;del_flag&#x27;, `create_by` bigint(200) DEFAULT NULL, `create_time` datetime DEFAULT NULL, `update_by` bigint(200) DEFAULT NULL, `update_time` datetime DEFAULT NULL, `remark` varchar(500) DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;角色表&#x27;;/*Table structure for table `sys_role_menu` */DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`,`menu_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;/*Table structure for table `sys_user` */DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint(20) DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint(20) DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int(11) DEFAULT &#x27;0&#x27; COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;;/*Table structure for table `sys_user_role` */DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint(200) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`,`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 1234567891011SELECT DISTINCT m.`perms`FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`WHERE user_id = 2 AND r.`status` = 0 AND m.`status` = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.sangeng.domain;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import com.fasterxml.jackson.annotation.JsonInclude;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;import java.util.Date;/** * 菜单表(Menu)实体类 * * @author makejava * @since 2021-11-24 15:30:08 */@TableName(value=&quot;sys_menu&quot;)@Data@AllArgsConstructor@NoArgsConstructor@JsonInclude(JsonInclude.Include.NON_NULL)public class Menu implements Serializable &#123; private static final long serialVersionUID = -54979041104113736L; @TableId private Long id; /** * 菜单名 */ private String menuName; /** * 路由地址 */ private String path; /** * 组件路径 */ private String component; /** * 菜单状态（0显示 1隐藏） */ private String visible; /** * 菜单状态（0正常 1停用） */ private String status; /** * 权限标识 */ private String perms; /** * 菜单图标 */ private String icon; private Long createBy; private Date createTime; private Long updateBy; private Date updateTime; /** * 是否删除（0未删除 1已删除） */ private Integer delFlag; /** * 备注 */ private String remark;&#125; 3.2.3.3 代码实现​ 我们只需要根据用户id去查询到其所对应的权限信息即可。 ​ 所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。 1234567891011import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.sangeng.domain.Menu;import java.util.List;/** * @Author 三更 B站： https://space.bilibili.com/663528522 */public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; ​ 尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sangeng.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.`perms` FROM sys_user_role ur LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id` LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id` LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id` WHERE user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; ​ 在application.yml中配置mapperXML文件的位置 123456789101112spring: datasource: url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver redis: host: localhost port: 6379mybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml ​ 然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。 1234567891011121314151617181920212223242526/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Autowired private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;(); wrapper.eq(User::getUserName,username); User user = userMapper.selectOne(wrapper); if(Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; List&lt;String&gt; permissionKeyList = menuMapper.selectPermsByUserId(user.getId());// //测试写法// List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;test&quot;)); return new LoginUser(user,permissionKeyList); &#125;&#125; 4. 自定义失败处理​ 我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。 ​ 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 ​ 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 ​ 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 ​ 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 ①自定义实现类 1234567891011@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; 12345678910111213/** * @Author 三更 B站： https://space.bilibili.com/663528522 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String json = JSON.toJSONString(result); WebUtils.renderString(response,json); &#125;&#125; ②配置给SpringSecurity ​ ​ 先注入对应的处理器 12345@Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; ​ 然后我们可以使用HttpSecurity对象的方法去配置。 12http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 5. 跨域​ 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 ​ 前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。 ​ 所以我们就要处理一下，让前端能进行跨域请求。 ①先对SpringBoot配置，运行跨域请求 12345678910111213141516171819@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; ②开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; 6. 遗留小问题其它权限校验方法​ 我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。 ​ ​ 这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。 ​ hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。 ​ 它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 ​ hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 1234@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; ​ hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 1234@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 自定义权限校验方法​ 我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。 123456789101112@Component(&quot;ex&quot;)public class SGExpressionRoot &#123; public boolean hasAuthority(String authority)&#123; //获取当前用户的权限 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); List&lt;String&gt; permissions = loginUser.getPermissions(); //判断用户权限集合中是否存在authority return permissions.contains(authority); &#125;&#125; ​ 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法 12345@RequestMapping(&quot;/hello&quot;)@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)public String hello()&#123; return &quot;hello&quot;;&#125; 基于配置的权限控制​ 我们也可以在配置类中使用使用配置的方式对资源进行权限控制。 123456789101112131415161718192021222324252627@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http //关闭csrf .csrf().disable() //不通过Session获取SecurityContext .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;).anonymous() .antMatchers(&quot;/testCors&quot;).hasAuthority(&quot;system:dept:list222&quot;) // 除上面外的所有请求全部需要鉴权认证 .anyRequest().authenticated(); //添加过滤器 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); //配置异常处理器 http.exceptionHandling() //配置认证失败处理器 .authenticationEntryPoint(authenticationEntryPoint) .accessDeniedHandler(accessDeniedHandler); //允许跨域 http.cors();&#125; CSRF​ CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。 ​ https://blog.csdn.net/freeking101/article/details/86537087 ​ SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。 ​ 我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。 认证成功处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。 ​ 我们也可以自己去自定义成功处理器进行成功后的相应处理。 123456789@Componentpublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;认证成功了&quot;); &#125;&#125; 1234567891011121314@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().successHandler(successHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 认证失败处理器​ 实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。 ​ 我们也可以自己去自定义失败处理器进行失败后的相应处理。 1234567@Componentpublic class SGFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; System.out.println(&quot;认证失败了&quot;); &#125;&#125; 123456789101112131415161718192021@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 登出成功处理器12345678@Componentpublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; System.out.println(&quot;注销成功&quot;); &#125;&#125; 123456789101112131415161718192021222324252627@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private AuthenticationSuccessHandler successHandler; @Autowired private AuthenticationFailureHandler failureHandler; @Autowired private LogoutSuccessHandler logoutSuccessHandler; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// 配置认证成功处理器 .successHandler(successHandler)// 配置认证失败处理器 .failureHandler(failureHandler); http.logout() //配置注销成功处理器 .logoutSuccessHandler(logoutSuccessHandler); http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 其他认证方案畅想7. 源码讲解​ 投票过50更新源码讲解","categories":[],"tags":[]},{"title":"my first blog","slug":"my-first-blog","date":"2022-09-14T07:40:01.000Z","updated":"2022-09-15T12:17:42.685Z","comments":true,"path":"2022/09/14/my-first-blog/","link":"","permalink":"http://example.com/2022/09/14/my-first-blog/","excerpt":"","text":"开启三个线程：1，从缓冲区读入帧，2、对每一帧分析识别装甲板灯条 3、读取机器人电控发来的信息 1 提取红蓝通道，进行图像形态学操作（二值化、膨胀、腐蚀）检测轮廓，找到符合要求的装甲板形态的图像区域用roi框出来，并且筛选掉与水平方向角度过大的roi框。 2 筛选符合两灯条的特征，两条灯条不平行、相隔距离超过阈值等情况筛选掉，并通过灯条的宽高比例，中心点的位置距离判断是否是所需要的灯条。最后用稍大一点的roi框出来，并确保不会越出图片的边界（使用的应该是rmuc代码） 3 对识别的灯条识别四个外角点，计算全图中的坐标，为PNP作准备 4 然后做PNP求解:相机坐标系相对于世界坐标系的位姿，（四元数转欧拉角），从而得到机器人云台到目标装甲板灯条的方位和相对距离，计算出偏航角和俯仰角，也就是yaw和pitch。 https://blog.csdn.net/weixin_44197735/article/details/124341862 5 最后通过这些数据把相机坐标系通过平移到枪管口坐标系做重力下坠模型或者平移到云台做位姿估计。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-09-14T05:24:44.822Z","updated":"2022-09-14T05:24:44.822Z","comments":true,"path":"2022/09/14/hello-world/","link":"","permalink":"http://example.com/2022/09/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"JWT实战","slug":"JWT 实战教程","date":"2022-07-20T01:00:01.000Z","updated":"2022-09-15T15:47:29.718Z","comments":true,"path":"2022/07/20/JWT 实战教程/","link":"","permalink":"http://example.com/2022/07/20/JWT%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B/","excerpt":"","text":"JWT 实战教程 1.什么是JWTJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public&#x2F;private key pair using RSA or ECDSA. ​ —[摘自官网] 123456# 1.翻译- 官网地址: https://jwt.io/introduction/- 翻译: jsonwebtoken（JWT）是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名# 2.通俗解释- JWT简称JSON Web Token,也就是通过JSON形式作为Web应用中的令牌,用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。 2.JWT能做什么12345# 1.授权- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。# 2.信息交换- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。 3.为什么是JWT基于传统的Session认证1234# 1.认证方式- 我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。# 2.认证流程 123456789# 3.暴露问题- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。- 4.在前后端分离系统中就更加痛苦:如下图所示 也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务 器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻 击）攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是 sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。 不方便集群应用。 基于JWT认证 1234567891011121314151617181920# 1.认证流程- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。# 2.jwt优势- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。- 不需要在服务端保存会话信息，特别适用于分布式微服务。 4.JWT的结构是什么?1234567token string ====&gt; header.payload.singnature token # 1.令牌组成- 1.标头(Header)- 2.有效载荷(Payload)- 3.签名(Signature)- 因此，JWT通常如下所示:xxxxx.yyyyy.zzzzz Header.Payload.Signature 1234# 2.Header- 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。- 注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 12# 3.Payload- 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 123456789101112# 4.Signature- 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过- 如: HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),secret);# 签名目的- 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。# 信息安全问题- 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？- 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。 123456# 5.放在一起- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。- 简洁(Compact) 可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快- 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 5.使用JWT1# 1.引入依赖 123456&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 1# 2.生成token 123456789Calendar instance = Calendar.getInstance();instance.add(Calendar.SECOND, 90);//生成令牌String token = JWT.create() .withClaim(&quot;username&quot;, &quot;张三&quot;)//设置自定义用户名 .withExpiresAt(instance.getTime())//设置过期时间 .sign(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;));//设置签名 保密 复杂//输出令牌System.out.println(token); 12- 生成结果eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg 1# 3.根据令牌和签名解析数据 1234JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;)).build();DecodedJWT decodedJWT = jwtVerifier.verify(token);System.out.println(&quot;用户名: &quot; + decodedJWT.getClaim(&quot;username&quot;).asString());System.out.println(&quot;过期时间: &quot;+decodedJWT.getExpiresAt()); 12345# 4.常见异常信息- SignatureVerificationException: 签名不一致异常- TokenExpiredException: 令牌过期异常- AlgorithmMismatchException: 算法不匹配异常- InvalidClaimException: 失效的payload异常 6.封装工具类12345678910111213141516171819202122232425262728293031323334public class JWTUtils &#123; private static String TOKEN = &quot;token!Q@W3e4r&quot;; /** * 生成token * @param map //传入payload * @return 返回token */ public static String getToken(Map&lt;String,String&gt; map)&#123; JWTCreator.Builder builder = JWT.create(); map.forEach((k,v)-&gt;&#123; builder.withClaim(k,v); &#125;); Calendar instance = Calendar.getInstance(); instance.add(Calendar.SECOND,7); builder.withExpiresAt(instance.getTime()); return builder.sign(Algorithm.HMAC256(TOKEN)).toString(); &#125; /** * 验证token * @param token * @return */ public static void verify(String token)&#123; JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125; /** * 获取token中payload * @param token * @return */ public static DecodedJWT getToken(String token)&#123; return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token); &#125;&#125; 7.整合springboot123# 0.搭建springboot+mybatis+jwt环境- 引入依赖- 编写配置 12345678910111213141516171819202122232425262728293031323334&lt;!--引入jwt--&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入lombok--&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入druid--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.19&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入mysql--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt; 12345678910111213server.port=8989spring.application.name=jwtspring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootmybatis.type-aliases-package=com.baizhi.entitymybatis.mapper-locations=classpath:com/baizhi/mapper/*.xmllogging.level.com.baizhi.dao=debug 12# 1.开发数据库- 这里采用最简单的表结构验证JWT使用 ![image-20200805212226422](JWT 实战教程.assets&#x2F;image-20200805212226422.png) 1234567DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `name` varchar(80) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `password` varchar(40) DEFAULT NULL COMMENT &#x27;用户密码&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; 1# 2.开发entity 1234567@Data@Accessors(chain=true)public class User &#123; private String id; private String name; private String password;&#125; 1# 3.开发DAO接口和mapper.xml 1234@Mapperpublic interface UserDAO &#123; User login(User user);&#125; 123456&lt;mapper namespace=&quot;com.baizhi.dao.UserDAO&quot;&gt; &lt;!--这里就写的简单点了毕竟不是重点--&gt; &lt;select id=&quot;login&quot; parameterType=&quot;User&quot; resultType=&quot;User&quot;&gt; select * from user where name=#&#123;name&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 1# 4.开发Service 接口以及实现类 123public interface UserService &#123; User login(User user);//登录接口&#125; 123456789101112131415@Service@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDAO userDAO; @Override @Transactional(propagation = Propagation.SUPPORTS) public User login(User user) &#123; User userDB = userDAO.login(user); if(userDB!=null)&#123; return userDB; &#125; throw new RuntimeException(&quot;登录失败~~&quot;); &#125;&#125; 1# 5.开发controller 123456789101112131415161718192021222324252627@RestController@Slf4jpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(&quot;/user/login&quot;) public Map&lt;String,Object&gt; login(User user) &#123; Map&lt;String,Object&gt; result = new HashMap&lt;&gt;(); log.info(&quot;用户名: [&#123;&#125;]&quot;, user.getName()); log.info(&quot;密码: [&#123;&#125;]&quot;, user.getPassword()); try &#123; User userDB = userService.login(user); Map&lt;String, String&gt; map = new HashMap&lt;&gt;();//用来存放payload map.put(&quot;id&quot;,userDB.getId()); map.put(&quot;username&quot;, userDB.getName()); String token = JWTUtils.getToken(map); result.put(&quot;state&quot;,true); result.put(&quot;msg&quot;,&quot;登录成功!!!&quot;); result.put(&quot;token&quot;,token); //成功返回token信息 &#125; catch (Exception e) &#123; e.printStackTrace(); result.put(&quot;state&quot;,&quot;false&quot;); result.put(&quot;msg&quot;,e.getMessage()); &#125; return result; &#125;&#125; 1# 6.数据库添加测试数据启动项目 1# 7.通过postman模拟登录失败 1# 8.通过postman模拟登录成功 1# 9.编写测试接口 1234567891011121314151617181920212223@PostMapping(&quot;/test/test&quot;)public Map&lt;String, Object&gt; test(String token) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); map.put(&quot;msg&quot;, &quot;验证通过~~~&quot;); map.put(&quot;state&quot;, true); &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; return map;&#125; 1# 10.通过postman请求接口 123# 11.问题?- 使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化- 使用拦截器进行优化 1234567891011121314151617181920212223242526@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String token = request.getHeader(&quot;token&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); try &#123; JWTUtils.verify(token); return true; &#125; catch (TokenExpiredException e) &#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;Token已经过期!!!&quot;); &#125; catch (SignatureVerificationException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;签名错误!!!&quot;); &#125; catch (AlgorithmMismatchException e)&#123; map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;加密算法不匹配!!!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(&quot;state&quot;, false); map.put(&quot;msg&quot;, &quot;无效token~~&quot;); &#125; String json = new ObjectMapper().writeValueAsString(map); response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().println(json); return false;&#125; 123456789@Componentpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new JwtTokenInterceptor()). excludePathPatterns(&quot;/user/**&quot;) .addPathPatterns(&quot;/**&quot;); &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}